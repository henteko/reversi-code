# プロジェクト名： **"ReversiCode"**

## 1. コンセプト & ターゲット

* **キャッチコピー:** AI Coding時代にこそ、手書きプログラミングバトル。
* **体験:** プレイヤーは「石」を置くのではなく、「ロジック」を置く。自分の思考をコードに落とし込み、ランクごとのCPU（門下生〜師範代）をなぎ倒していく。
* **ターゲット:** TypeScript/JavaScript開発者、アルゴリズム学習者、Vim/Terminal愛好家。

## 2. 画面構成 (TUIレイアウト)

ターミナル画面を3分割して使用します。

| エリア | 説明 |
| --- | --- |
| **左側：Game Board** | 現在のオセロ盤面、スコア、ターン表示、ログ（「Player Aが(3,4)に置きました」など）を表示。 |
| **右側：Code Editor** | 簡易コードエディタ。シンタックスハイライト付き。Vimモード/標準モード切替可能。 |
| **下部：Status/Control** | 現在の対戦相手（ランク）、実行ステータス（コンパイル中、思考中）、ショートカットキー案内。 |

## 3. 技術スタック案

TypeScriptエコシステムで完結させる構成が最もスムーズです。

* **ランタイム:** Node.js (または Deno)
* **UIフレームワーク:** **Ink** (ReactベースでTUIを作るライブラリ)
* 複雑なレイアウトやステート管理（エディタとゲームの連動）が容易なため。


* **エディタコンポーネント:** `ink-text-input` を拡張 または `react-ace` のようなロジックを自作（単純な行管理）。
* **サンドボックス (重要):**
* **`isolated-vm`** または **Node.js `vm` module** (with strict context)。
* ユーザーのTSコードをオンメモリでトランスパイル（`esbuild` or `swc`使用で高速化）し、隔離環境で実行します。


* **外部ライブラリ制限:** サンドボックス内で `require` や `import` を無効化し、標準の算術演算と提供された型定義のみ使用可能にします。
* **通信の制限:** サンドボックス内からの外部通信は全て無効化する。

## 4. ゲームシステム詳細

### A. プレイヤーが書くコード (インターフェース)

プレイヤーには、毎ターン呼び出される関数 `decideMove` を実装してもらいます。

```typescript
// プレイヤーに提供される型定義
type Board = number[][]; // 0: 空, 1: 黒, -1: 白
type PlayerColor = 1 | -1;

// プレイヤーが書くスクリプトのイメージ
function decideMove(board: Board, myColor: PlayerColor): [number, number] {
  // ここにロジックを書く
  
  // 例: ランダムに空いている場所を探す（弱い）
  // 例: 角を取れるなら取る（中級）
  // 例: ミニマックス法で探索（上級）
  
  return [x, y]; 
}

```

### B. 対戦の流れ

1. **Rank Select:** 対戦するCPUのランクを選択（E〜Sランク）。
2. **Coding Phase:** エディタ画面で戦略をコーディング。
3. **Deploy & Battle:** 「Deploy」キー（例: Ctrl+Enter）を押すと、即座にコンパイルが走り、ゲーム開始。
* エラーがあればログに出力して停止（デバッグ体験）。
* 無限ループ対策として、1手あたりの実行時間制限（例: 1000ms）を設ける。


4. **Result:** 勝敗判定。勝てば次のランクがアンロックされる。

### C. CPUのランク設計 (敵の強さ)

* **Rank E (Novice):** ランダム打ち。ルール通りに置ける場所に適当に置く。
* **Rank C (Apprentice):** 貪欲法（Greedy）。そのターンで一番多く取れる場所、または角（Corner）を優先する。
* **Rank A (Expert):** ミニマックス法 + アルファベータ法（3手読み程度）。評価関数による盤面判断。
* **Rank S (Master):** ビットボード実装による高速化 + 深い探索、または確定石重視の高度な評価関数。

